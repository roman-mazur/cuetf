package res

#elasticstack_kibana_security_detection_rule: {
	@jsonschema(schema="https://json-schema.org/draft/2020-12/schema")
	@jsonschema(id="https://github.com/roman-mazur/cuetf/schema/elasticstack_kibana_security_detection_rule")
	close({
		// Array of automated actions taken when alerts are generated by
		// the rule.
		actions?: matchN(1, [close({
			// The action type used for sending notifications (e.g., .slack,
			// .email, .webhook, .pagerduty, etc.).
			action_type_id!: string

			// Object containing an action's conditional filters.
			alerts_filter?: [string]: string

			// The action frequency defines when the action runs.
			frequency?: close({
				// Defines how often rules run actions. Valid values:
				// onActionGroupChange, onActiveAlert, onThrottleInterval.
				notify_when!: string

				// Action summary indicates whether we will send a summary
				// notification about all the generated alerts or notification
				// per individual alert.
				summary!: bool

				// Time interval for throttling actions (e.g., '1h', '30m',
				// 'no_actions', 'rule').
				throttle!: string
			})

			// Optionally groups actions by use cases. Use 'default' for alert
			// notifications.
			group?: string

			// The connector ID.
			id!: string

			// Object containing the allowed connector fields, which varies
			// according to the connector type.
			params!: [string]: string

			// A unique identifier for the action.
			uuid?: string
		}), [...close({
			// The action type used for sending notifications (e.g., .slack,
			// .email, .webhook, .pagerduty, etc.).
			action_type_id!: string

			// Object containing an action's conditional filters.
			alerts_filter?: [string]: string

			// The action frequency defines when the action runs.
			frequency?: close({
				// Defines how often rules run actions. Valid values:
				// onActionGroupChange, onActiveAlert, onThrottleInterval.
				notify_when!: string

				// Action summary indicates whether we will send a summary
				// notification about all the generated alerts or notification
				// per individual alert.
				summary!: bool

				// Time interval for throttling actions (e.g., '1h', '30m',
				// 'no_actions', 'rule').
				throttle!: string
			})

			// Optionally groups actions by use cases. Use 'default' for alert
			// notifications.
			group?: string

			// The connector ID.
			id!: string

			// Object containing the allowed connector fields, which varies
			// according to the connector type.
			params!: [string]: string

			// A unique identifier for the action.
			uuid?: string
		})]])

		// Defines alert suppression configuration to reduce duplicate
		// alerts.
		alert_suppression?: close({
			// Duration for which alerts are suppressed.
			duration?: string

			// Array of field names to group alerts by for suppression.
			group_by?: [...string]

			// Strategy for handling missing fields in suppression grouping:
			// 'suppress' - only one alert will be created per suppress by
			// bucket, 'doNotSuppress' - per each document a separate alert
			// will be created.
			missing_fields_strategy?: string
		})

		// Anomaly score threshold above which the rule creates an alert.
		// Valid values are from 0 to 100. Required for machine_learning
		// rules.
		anomaly_threshold?: number

		// The rule's author.
		author?: [...string]

		// Determines if the rule acts as a building block. If set, value
		// must be `default`. Building-block alerts are not displayed in
		// the UI by default and are used as a foundation for other
		// rules.
		building_block_type?: string

		// Number of concurrent searches for threat intelligence. Optional
		// for threat_match rules.
		concurrent_searches?: number

		// The time the rule was created.
		created_at?: string

		// The user who created the rule.
		created_by?: string

		// Data view ID for the rule. Not supported for esql and
		// machine_learning rule types.
		data_view_id?: string

		// The rule's description.
		description!: string

		// Determines whether the rule is enabled.
		enabled?: bool

		// String array used to describe common reasons why the rule may
		// issue false-positive alerts.
		false_positives?: [...string]

		// Array of exception containers to prevent the rule from
		// generating alerts.
		exceptions_list?: matchN(1, [close({
			// The exception container ID.
			id!: string

			// The exception container's list ID.
			list_id!: string

			// The namespace type for the exception container.
			namespace_type!: string

			// The type of exception container.
			type!: string
		}), [...close({
			// The exception container ID.
			id!: string

			// The exception container's list ID.
			list_id!: string

			// The namespace type for the exception container.
			namespace_type!: string

			// The type of exception container.
			type!: string
		})]])

		// Query and filter context array to define alert conditions as
		// JSON. Supports complex filter structures including bool
		// queries, term filters, range filters, etc. Available for all
		// rule types.
		filters?: string

		// Time from which data is analyzed each time the rule runs, using
		// a date math range.
		from?: string

		// Start date to use when checking if a term has been seen before.
		// Supports relative dates like 'now-30d'. Required for new_terms
		// rules.
		history_window_start?: string

		// Internal identifier of the resource
		id?: string

		// Indices on which the rule functions.
		index?: [...string]

		// Array of related integrations that provide additional context
		// for the rule.
		related_integrations?: matchN(1, [close({
			// Name of the specific integration.
			integration?: string

			// Name of the integration package.
			package!: string

			// Version of the integration package.
			version!: string
		}), [...close({
			// Name of the specific integration.
			integration?: string

			// Name of the integration package.
			package!: string

			// Version of the integration package.
			version!: string
		})]])

		// Frequency of rule execution, using a date math range.
		interval?: string

		// Array of field names to include in alert investigation.
		// Available for all rule types.
		investigation_fields?: [...string]

		// Number of items to search for in each concurrent search.
		// Optional for threat_match rules.
		items_per_search?: number

		// Array of Elasticsearch fields and types that must be present in
		// source indices for the rule to function properly.
		required_fields?: matchN(1, [close({
			// Indicates whether the field is ECS-compliant. This is computed
			// by the backend based on the field name and type.
			ecs?: bool

			// Name of the Elasticsearch field.
			name!: string

			// Type of the Elasticsearch field.
			type!: string
		}), [...close({
			// Indicates whether the field is ECS-compliant. This is computed
			// by the backend based on the field name and type.
			ecs?: bool

			// Name of the Elasticsearch field.
			name!: string

			// Type of the Elasticsearch field.
			type!: string
		})]])

		// The query language (KQL or Lucene).
		language?: string

		// The rule's license.
		license?: string

		// Machine learning job ID(s) the rule monitors for anomaly
		// scores. Required for machine_learning rules.
		machine_learning_job_id?: [...string]

		// Maximum number of alerts the rule can create during a single
		// run.
		max_signals?: number

		// A human-readable name for the rule.
		name!: string

		// Alerts index namespace. Available for all rule types.
		namespace?: string

		// Field names containing the new terms. Required for new_terms
		// rules.
		new_terms_fields?: [...string]

		// Notes to help investigate alerts produced by the rule.
		note?: string

		// Array of response actions to take when alerts are generated by
		// the rule.
		response_actions?: matchN(1, [close({
			// The action type used for response actions (.osquery,
			// .endpoint).
			action_type_id!: string

			// Parameters for the response action. Structure varies based on
			// action_type_id.
			params!: close({
				// Configuration for process commands (endpoint only).
				config?: close({
					// Field to use instead of process.pid.
					field!: string

					// Whether to overwrite field with process.pid.
					overwrite?: bool
				})

				// Array of queries to run (osquery only).
				queries?: matchN(1, [close({
					// ECS field mappings for this query.
					ecs_mapping?: [string]: string

					// Query ID.
					id!: string

					// Platform to run the query on.
					platform?: string

					// Query to run.
					query!: string

					// Whether the query is removed.
					removed?: bool

					// Whether this is a snapshot query.
					snapshot?: bool

					// Query version.
					version?: string
				}), [...close({
					// ECS field mappings for this query.
					ecs_mapping?: [string]: string

					// Query ID.
					id!: string

					// Platform to run the query on.
					platform?: string

					// Query to run.
					query!: string

					// Whether the query is removed.
					removed?: bool

					// Whether this is a snapshot query.
					snapshot?: bool

					// Query version.
					version?: string
				})]])

				// Command to run (endpoint only). Valid values: isolate,
				// kill-process, suspend-process.
				command?: string

				// Comment describing the action (endpoint only).
				comment?: string

				// Map Osquery results columns to ECS fields (osquery only).
				ecs_mapping?: [string]: string

				// Query pack identifier (osquery only).
				pack_id?: string

				// SQL query to run (osquery only). Example: 'SELECT * FROM
				// processes;'
				query?: string

				// Saved query identifier (osquery only).
				saved_query_id?: string

				// Timeout period in seconds (osquery only). Min: 60, Max: 900.
				timeout?: number
			})
		}), [...close({
			// The action type used for response actions (.osquery,
			// .endpoint).
			action_type_id!: string

			// Parameters for the response action. Structure varies based on
			// action_type_id.
			params!: close({
				// Configuration for process commands (endpoint only).
				config?: close({
					// Field to use instead of process.pid.
					field!: string

					// Whether to overwrite field with process.pid.
					overwrite?: bool
				})

				// Array of queries to run (osquery only).
				queries?: matchN(1, [close({
					// ECS field mappings for this query.
					ecs_mapping?: [string]: string

					// Query ID.
					id!: string

					// Platform to run the query on.
					platform?: string

					// Query to run.
					query!: string

					// Whether the query is removed.
					removed?: bool

					// Whether this is a snapshot query.
					snapshot?: bool

					// Query version.
					version?: string
				}), [...close({
					// ECS field mappings for this query.
					ecs_mapping?: [string]: string

					// Query ID.
					id!: string

					// Platform to run the query on.
					platform?: string

					// Query to run.
					query!: string

					// Whether the query is removed.
					removed?: bool

					// Whether this is a snapshot query.
					snapshot?: bool

					// Query version.
					version?: string
				})]])

				// Command to run (endpoint only). Valid values: isolate,
				// kill-process, suspend-process.
				command?: string

				// Comment describing the action (endpoint only).
				comment?: string

				// Map Osquery results columns to ECS fields (osquery only).
				ecs_mapping?: [string]: string

				// Query pack identifier (osquery only).
				pack_id?: string

				// SQL query to run (osquery only). Example: 'SELECT * FROM
				// processes;'
				query?: string

				// Saved query identifier (osquery only).
				saved_query_id?: string

				// Timeout period in seconds (osquery only). Min: 60, Max: 900.
				timeout?: number
			})
		})]])

		// The query language definition.
		query?: string

		// Array of risk score mappings to override the default risk score
		// based on source event field values.
		risk_score_mapping?: matchN(1, [close({
			// Source event field used to override the default risk_score.
			field!: string

			// Operator to use for field value matching. Currently only
			// 'equals' is supported.
			operator!: string

			// Risk score to use when the field matches the value (0-100). If
			// omitted, uses the rule's default risk_score.
			risk_score?: number

			// Value to match against the field.
			value!: string
		}), [...close({
			// Source event field used to override the default risk_score.
			field!: string

			// Operator to use for field value matching. Currently only
			// 'equals' is supported.
			operator!: string

			// Risk score to use when the field matches the value (0-100). If
			// omitted, uses the rule's default risk_score.
			risk_score?: number

			// Value to match against the field.
			value!: string
		})]])

		// String array containing references and URLs to sources of
		// additional information.
		references?: [...string]

		// Array of severity mappings to override the default severity
		// based on source event field values.
		severity_mapping?: matchN(1, [close({
			// Source event field used to override the default severity.
			field!: string

			// Operator to use for field value matching. Currently only
			// 'equals' is supported.
			operator!: string

			// Severity level to use when the field matches the value.
			severity!: string

			// Value to match against the field.
			value!: string
		}), [...close({
			// Source event field used to override the default severity.
			field!: string

			// Operator to use for field value matching. Currently only
			// 'equals' is supported.
			operator!: string

			// Severity level to use when the field matches the value.
			severity!: string

			// Value to match against the field.
			value!: string
		})]])

		// MITRE ATT&CK framework threat information.
		threat?: matchN(1, [close({
			// MITRE ATT&CK tactic information.
			tactic!: close({
				// MITRE ATT&CK tactic ID.
				id!: string

				// MITRE ATT&CK tactic name.
				name!: string

				// MITRE ATT&CK tactic reference URL.
				reference!: string
			})

			// Threat framework (typically 'MITRE ATT&CK').
			framework!: string

			// MITRE ATT&CK technique information.
			technique?: matchN(1, [close({
				// MITRE ATT&CK technique ID.
				id!: string

				// MITRE ATT&CK technique name.
				name!: string

				// MITRE ATT&CK sub-technique information.
				subtechnique?: matchN(1, [close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				}), [...close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				})]])

				// MITRE ATT&CK technique reference URL.
				reference!: string
			}), [...close({
				// MITRE ATT&CK technique ID.
				id!: string

				// MITRE ATT&CK technique name.
				name!: string

				// MITRE ATT&CK sub-technique information.
				subtechnique?: matchN(1, [close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				}), [...close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				})]])

				// MITRE ATT&CK technique reference URL.
				reference!: string
			})]])
		}), [...close({
			// MITRE ATT&CK tactic information.
			tactic!: close({
				// MITRE ATT&CK tactic ID.
				id!: string

				// MITRE ATT&CK tactic name.
				name!: string

				// MITRE ATT&CK tactic reference URL.
				reference!: string
			})

			// Threat framework (typically 'MITRE ATT&CK').
			framework!: string

			// MITRE ATT&CK technique information.
			technique?: matchN(1, [close({
				// MITRE ATT&CK technique ID.
				id!: string

				// MITRE ATT&CK technique name.
				name!: string

				// MITRE ATT&CK sub-technique information.
				subtechnique?: matchN(1, [close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				}), [...close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				})]])

				// MITRE ATT&CK technique reference URL.
				reference!: string
			}), [...close({
				// MITRE ATT&CK technique ID.
				id!: string

				// MITRE ATT&CK technique name.
				name!: string

				// MITRE ATT&CK sub-technique information.
				subtechnique?: matchN(1, [close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				}), [...close({
					// MITRE ATT&CK sub-technique ID.
					id!: string

					// MITRE ATT&CK sub-technique name.
					name!: string

					// MITRE ATT&CK sub-technique reference URL.
					reference!: string
				})]])

				// MITRE ATT&CK technique reference URL.
				reference!: string
			})]])
		})]])

		// Array of threat mappings that specify how to match events with
		// threat intelligence. Required for threat_match rules.
		threat_mapping?: matchN(1, [close({
			// Array of mapping entries.
			entries!: matchN(1, [close({
				// Event field to match.
				field!: string

				// Type of match (mapping).
				type!: string

				// Threat intelligence field to match against.
				value!: string
			}), [...close({
				// Event field to match.
				field!: string

				// Type of match (mapping).
				type!: string

				// Threat intelligence field to match against.
				value!: string
			})]])
		}), [...close({
			// Array of mapping entries.
			entries!: matchN(1, [close({
				// Event field to match.
				field!: string

				// Type of match (mapping).
				type!: string

				// Threat intelligence field to match against.
				value!: string
			}), [...close({
				// Event field to match.
				field!: string

				// Type of match (mapping).
				type!: string

				// Threat intelligence field to match against.
				value!: string
			})]])
		})]])

		// The rule's revision number.
		revision?: number

		// A numerical representation of the alert's severity from 0 to
		// 100.
		risk_score?: number

		// A stable unique identifier for the rule object. If omitted, a
		// UUID is generated.
		rule_id?: string

		// Override the rule name in Kibana. Available for all rule types.
		rule_name_override?: string

		// Identifier of the saved query used for the rule. Required for
		// saved_query rules.
		saved_id?: string

		// Setup guide with instructions on rule prerequisites.
		setup?: string

		// Severity level of alerts produced by the rule.
		severity?: string

		// Threshold settings for the rule. Required for threshold rules.
		threshold?: close({
			// Field(s) to use for threshold aggregation.
			field?: [...string]

			// Cardinality settings for threshold rule.
			cardinality?: matchN(1, [close({
				// The field on which to calculate and compare the cardinality.
				field!: string

				// The threshold cardinality value.
				value!: number
			}), [...close({
				// The field on which to calculate and compare the cardinality.
				field!: string

				// The threshold cardinality value.
				value!: number
			})]])

			// The threshold value from which an alert is generated.
			value!: number
		})

		// An identifier for the space. If space_id is not provided, the
		// default space is used.
		space_id?: string

		// String array containing words and phrases to help categorize,
		// filter, and search rules.
		tags?: [...string]

		// Additional filters for threat intelligence data. Optional for
		// threat_match rules.
		threat_filters?: [...string]

		// Array of index patterns for the threat intelligence indices.
		// Required for threat_match rules.
		threat_index?: [...string]

		// Path to the threat indicator in the indicator documents.
		// Optional for threat_match rules.
		threat_indicator_path?: string

		// Query used to filter threat intelligence data. Optional for
		// threat_match rules.
		threat_query?: string

		// Sets the tiebreaker field. Required for EQL rules when
		// event.dataset is not provided.
		tiebreaker_field?: string

		// Timeline template ID for the rule.
		timeline_id?: string

		// Timeline template title for the rule.
		timeline_title?: string

		// Field name to use for timestamp override. Available for all
		// rule types.
		timestamp_override?: string

		// Disables timestamp override fallback. Available for all rule
		// types.
		timestamp_override_fallback_disabled?: bool

		// Time to which data is analyzed each time the rule runs, using a
		// date math range.
		to?: string

		// Rule type. Supported types: query, eql, esql, machine_learning,
		// new_terms, saved_query, threat_match, threshold.
		type!: string

		// The time the rule was last updated.
		updated_at?: string

		// The user who last updated the rule.
		updated_by?: string

		// The rule's version number.
		version?: number
	})
}
